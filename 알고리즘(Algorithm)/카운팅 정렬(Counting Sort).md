# 카운팅 정렬(Counting Sort)

## 카운팅 정렬이란?
* 각 요소들을 그대로 저장하지 않고, 요소들의 '개수'를 세어 정렬하는 알고리즘.       

    * 요소의 값이 몇 번 등장하는지 세고, 그 정보를 바탕으로 정렬.
    * 대량의 데이터를 정렬할 때 유용
    * **값의 범위가 제한적일 때 가장 잘 작동한다.**         
    * **값의 범위가 크면 메모리를 많이 요구하게 되어 효율성이 떨어짐.**

## 카운팅 정렬이 필요하게 된 백준 문제.
[백준 10989번 문제](https://www.acmicpc.net/problem/10989)
* 10989번: 문제 수 정렬하기 3 - 브론즈 1티어        

이 문제를 처음 봤을 때 버블 정렬(Bubble Sort)을 사용해서 문제에 접근했다.    
그렇게 코드를 제출하니 메모리 초과가 뜨면서 실패했다.       
자세히 보니 메모리 제한이 8MB였다.      
최대 개수가 10,000,000인 점을 보았을 때 int의 크기 4 * 1,000,000을 하면 40MB가 나오면서 메모리 초과가 나오는 것이다.        
메모리 제한으로 인해 일반적인 배열 정렬로는 이 문제를 풀 수 없었다.     
그 후 이 문제를 풀 방법을 찾아보다가 카운팅 정렬을 찾게 됐다.

## 카운팅 정렬의 원리
우선 카운팅 정렬은 배열 3가지를 사용한다.       

    1. 입력 배열: 정렬할 요소들이 들어있는 배열
    2. 카운트 배열: 각 요소의 개수를 저장하는 배열
    3. 정렬된 배열: 정렬된 요소들을 저장하는 배열       

1. int arr[5] = { 5, 2, 4, 2, 3 } -> int count[4] = {2, 1, 1, 1}
2. int count[4] = {2, 3, 4, 5} -> int count[4] = {1, 2, 3, 4}
3. arr[0] = 5 -> count[4] = 4, 5를 result 배열의 5번째 인덱스에 저장 후 카운트 배열 값 -1. 반복.
* int result[5] = {0, 0, 0, 0, 5} -> int count[4] = {1, 2, 3, 3}
* int result[5] = {0, 2, 0, 0, 5} -> int count[4] = {0, 2, 3, 3}
* int result[5] = {0, 2, 0, 4, 5} -> int count[4] = {0, 2, 2, 3}
* int result[5] = {2, 2, 0, 4, 5} -> int count[4] = {-1, 2, 2, 3}
* int result[5] = {2, 2, 3, 4, 5} -> int count[4] = {-1, 1, 2, 3}           

1. 입력 배열의 요소의 개수를 카운트 배열에 저장한다. (카운트 배열의 크기: 최댓값 - 최솟값 + 1)
2. 카운트 배열(count[i])에 각 요소의 누적 빈도를 저장하고 -1을 해준다. (count[i + 1] += count[i])       
3. 입력 배열의 요소 값에 해당하는 값을 카운트 배열에서 찾아 정렬된 배열에 삽입한다.


